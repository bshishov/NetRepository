h1. NetRepository

Локальный репозиторий, представляющий собой C# библиотеку, служащую промежуточным звеном между БД и приложением. Позволяет управлять версиями свойств различных объектов. 


h2. Терминология

*Свойство* - пара ключ-значение в которой и содержится полезная информация. Имеет свой уникальный идентификатор внутри объекта, ссылку на объект, и ссылку на срез в котором свойство актуально.

*Срез данных* (Slice) — совокупность свойств относящихся к одному промежутку времени. Аналогией может послужить Commit из систем контроля версий. Содержит ссылку на родительский срез для возможности реализации древовидной структуры. Имеет свой идентификатор.

*Объект* — неверсионируемая сущность репозитория. Содержит в себе совокупность свойств, относящихся к данном объекту. Имеет свой уникальный идентификатор и тип (строковое значение).

*Ветка* - Линейная последовательность срезов от текущего среза до корневого.


h2. Как устроено

По-умолчанию все данные репозитория хранятся в базе данных SQLite. 
В ней присутствуют следующие таблицы (системные не показаны):

* *Objects* - Таблица объектов. В ней хранятся все объекты, вне зависимости от версии свойств Поля: _id_ - уникальный идентификатор объекта, _type_ - тип объекта

* *Data* - Таблица свойств. В ней хранятся все версии всех свойств. Поля: _slice_id_ - идентификатор среза, _object_id_ - идентификатор объекта, _key_ - ключ, уникально идентифицирующий свойство внутри объекта, _value_ - значение свойства

* *Slices* - Таблица срезов. Содержит в себе все срезы репозитория. Поля: _id_ - идентификатор среза, _parent_clice_id_ - идентификатор родительского среза (требуется для реализации веток)

_также имеются несколько системных таблиц, индексов и триггеров для увеличения производительности репозитория_

Основной функционал репозитория реализован с помощью SQL запросов, которые при удачном сочетании с индексами дает высокую производительность. Т.е. все "версионирование" свойств объектов переложено на SQL запросы.

С# библиотека представляют собой обертку над этими запросами и правильно представляет данные, логически поддерживая целостность данных в репозитории.

Но т.к. SQL запросы все же не мгновенны, то был реализован кеширующий слой, позволяющий сделать выборку нескольких объектов сразу и оставить в памяти, а потом вносить в базу данные только тех, кто изменился.

h3. Конкретно

_Подробное описание классов методов и свойств можете найти в исходном коде_

h4. Менеджер

В C# репозиторий представляет собой объект класса SQLiteRepositoryManager (далее менеджер).
Менеджер - это *основной* объект работы с репозиторием. Все действия других классов и объектов так или иначе завязаны на методах менеджера. Содержит свойство @CurrentSlice@ которое содержит информацию о текущем срезе (идентификатор и идентификатор родительского среза).
Содержит основные методы работы с базой напрямую (без кеширования). Например:

Методы Работы со свойствами:

* @Attach(Property property)@ - Присоединяет свойство к менеджеру (т.е. себе), устанавливает ссылки. Устанавливает состояние Added
* @Property CreateProperty(objectId, property, value)@ - Создает свойство и сразу же присоединяет к себе (Attach). 
* @object GetProperty(objectId, property)@ - Загружает из базы из текущего среза свойство с указанным идентификатором
* @void SetProperty(objectId, property, value)@ - Записывает в базу в текущий срез данные о свойстве
* @void SetProperty(Property)@ - Записывает в базу в текущий срез данные о свойстве
* @Property[] GetObjectProperties(objectId)@ - Получает все свойства из базы из текущего среза для указанного идентификатора объекта

Методы Работы с объектами:

* @Attach(ObjectEntry object)@ - Присоединяет объект к менеджеру (т.е. себе), устанавливает ссылки. Устанавливает состояние Added
* @ObjectEntry CreateObject(id, type)@ - Создает объект и присоединяет его к себе (Attach).
* @void GetObject(id)@ - Получает объект по указанному идентификатору

Методы Работы с объектами:

* @void SetCurrentSlice(slice)@ - Переключает текущий срез на указанный
* @Slice AddSlice(parentSlice)@ - Создает и добавляет базу новый срез, не переключается на него


h4. Сущности репозитория

*RepoEntity* - абстрактный базовый класс для всех сущностей репозитория, таких как ObjectEntry (объект репозитория) и Property (свойство). У RepoEntity есть свойство State (состояние), которое отображет текущее состояни сущности, возможны варианты: 

* *Added*, Cущность связана с менеджером, но не с базой

* *Unchanged*, Сущность связана с базой и менеджером, нет изменений

* *Modified*,  Сущность связана с базой и менеджером, имеются изменения        

* *Deleted*, Связана с базой и менеджером, помечена на удаление и при следующем коммите будет удалена

* *Detached*, Сущность не связана с менеджером с базой

Имеет ссылку на менеджер, и идентификатор среза в котором сущность была создана (для проверки актуальности данных)

*Property*
Свойства представлены в коде в виде класса Property.
Имеет свойство Value - хранящее значение этого свойства.
Если свойство создавалось не методом @manager.CreateProperty(...)@ то необходимо выполнить @manager.Attach(property)@ это свяжет свойство с менеджером.

Основные методы:

* @Save()@ - вносит данные из поля @Value@ в базу 


*ObjectEntry*
Объекты представлены в виде класса ObjectEntry. Стоит отметить, что объект этого класс НЕ хранит в себе свойств объекта (этим занимеается CachedObject), а лишь имеет несколько методов для их получения из базы.

Основные методы:

* @GetProperties()@ - Получение всех свойств объекта в текущем срезе
* @Save()@ - сохраняет в базу объект, если его там не было (без его свойств)

h4. Кеширование

В целом, представленных выше методов достаточно для работы с репозиторием, но иногда все же требуется кеширование. Для этого в библиотеке есть 2 дополнительных класса @CachedRepository@ и @CachedObject@. Работа с кешированным объектом и репозиторием отличается от работы с обычным менеджером и объектом тем, что все изменения происходят локально, и только при вызове метода @Commit@ у кеширующего репозитория данные попадут в базу. Это увеличивает производительность за счет того что SQL запросы выполняются в одну транзакцию. 

*CachedRepository*
Кеширующий слой репозитория. Содержит коллекцию @CachedObject@, который в свою очередь содержит коллекцию из @Property@, вот и все кеширование :) 
@CachedRepository@ - шаблонный класс. В качестве типа можно поставить свой класс унаследованный от @CachedObject@, что весьма удобно. *Кеширующий репозиторий привязан к типу объекта*, тип указывается в конструкторе. При создании тут же вызовется метод @Refresh@ который загрузит из базы во внутреннюю коллекцию все объекты из текущего среза с указанным типом. 

Методы:

* @void AttachObject(T obj)@ - присоединяет объект, необходимо, если объект был создан без метода @CreateObject()@
* @T GetObject(TObjKey objKey)@ - Возвращает объект из внутренней коллекции
* @T CreateObject(TObjKey objKey)@ - Создает объект, настраивает все ссылки, и добавляет в коллекцию
* @bool HasChanges()@ - True если есть объекты и свойства с состоянием "Modified"
* @void Refresh()@ - Обновляет данные актуальными из базы (ит текущего среза)
* @void Commit()@ - Записывает в базу объекты и свойства с состоянием "Modified" (итерируя коллекцию вызывает метод @Save@ у каждого @CachedObject@)

*CachedObject*
Кешированный объект. Наследован от обычного @ObjectEntry@. Содержит в себе коллекцию свойств и их значений. Переопределяет родительский метод Save().

Методы:

* @SetProperty(id, value)@ - Устанавливает значение свойства в собственной коллекции
* @GetProperty(id)@ - Получает свойство из внутренней коллекции
* @Refresh()@ - Получает актуальные данные из текущего среза из менеджера
* @Save()@ - Сохраняет "Unchanged" свойства в базу.


h2. Пример использования

h3. Без кеширования

Создаем менеджер, указываем где создать/открыть базу

bc. SQLiteRepositoryManager manager = new SQLiteRepositoryManager("path_to_my_db.db3");

Создаем начальный срез и переключаемся на него

bc. Slice newSlice = manager.AddSlice(manager.CurrentSlice); // текущий в качестве родительского
manager.SetCurrentSlice(newSlice);

Создаем объект, указываем тип и идентификатор

bc. var obj = manager.CreateObject(0, "myType")

Задаем значение свойствам с идентификатором "1" и "2"

bc. obj.SetProperty(1,"foo");      
obj.SetProperty(2,"bar");      

Создаем и переходим на следующий срез

bc. manager.SetCurrentSlice(manager.AddSlice(manager.CurrentSlice));

Зададим свойство 

bc. obj.SetProperty(1,"baz"); 

Проверим результат, Получим свойства, указанные выше. Параметры: id объекта, id свойства

bc. string p1 = (string)manager.GetProperty(0,1).Value; // baz
string p2 = (string)manager.GetProperty(0,2).Value; // bar

Вернемся на прошлый срез и снова посмотрим результат.

bc. manager.SetCurrentSlice(newSlice);
string p3 = (string)manager.GetProperty(0,1).Value; // foo
string p4 = (string)manager.GetProperty(0,2).Value; // bar

И видим как версионируется свойство "1" у объекта "0"


h3. Пример с кешированием

Создадим менеджер репозитория

bc. SQLiteRepositoryManager manager = new SQLiteRepositoryManager();            

Создаем начальный срез и переключаемся на него           

bc. Slice root = manager.AddNextSlice();
manager.SetCurrentSlice(root);

Создадим кеширующий репозиторий объектов MyClass (наследован от CachedObject) и назовем его "myClass Objects"

bc. var repository = manager.CreateRepo<MyClass>("myClass Objects");

Есть 2 способа создать кешированный объект:
1. Вызвать метод кеширующего репозитория

bc. var myObject1 = repository.CreateObject();

2. Создать самому и прикрепить к кеширующему репозиторию

bc. var myObject2 = new MyClass();
repository.AttachObject(myObject2);

Зададим значения

bc. myObject1.SetProperty(0, "myValue1");
myObject2.SetProperty(0, "myValue2");

Сохраним изменения

bc. repository.Commit();

Создаем и переходим на следующий срез

bc. manager.SetCurrentSlice(manager.AddNextSlice());

Зададим свойство

bc. myObject1.SetProperty(0, "myValue3");

Сохраним изменения

bc. repository.Commit();

Проверим результат, Получим свойства, указанные выше. Параметры: id свойства            

bc. string p1 = (string)myObject1.GetProperty(0).Value; // myValue3
string p2 = (string)myObject2.GetProperty(0).Value; // myValue2

Вернемся на прошлый срез и снова посмотрим результат.

bc. manager.SetCurrentSlice(root);
repository.Refresh();
string p3 = (string)myObject1.GetProperty(0).Value; // myValue1
string p4 = (string)myObject2.GetProperty(0).Value; // myValue2